PROGRAM : TRAFFIC LIGHT CONTROLLER
Library ieee;
Use ieee.std_logic_1164.all;
Use ieee.numeric_std.all;  
Entity TLC is
    Port( clk : in std_logic ;  reset : in std_logic; d : in std_logic_vector(1 downto 0); 
        X : out std_logic_vector(8 downto 0));
End TLC;
Architecture Behavioral of TLC is
    type states is (A, B, C, E);
    signal state   : states := A;             -- Initial state is A
    signal timer   : std_logic_vector(1 downto 0) := "00";  -- 2-bit timer
    signal ten     : std_logic := '0';         -- Timer enable signal
Begin
process(clk)
    begin
        if (clk'event and clk = '1') then
            if ten = '0' then
                timer <= "00";  -- Reset timer to 00 when ten is 
             else
                timer <= std_logic_vector(unsigned(timer) + 1);  -- Increment timer
            end if; end if;
    end process;
process(clk, reset)
    begin
        if reset = '1' then
            state <= A;
            ten <= '0';         -- Disable timer
            X <= "100010010";   -- Initial output value (for state A)
        elsif rising_edge(clk) then
            case state is
                when A =>
                    if unsigned(timer) /= unsigned(d) then
                        state <= A;
                        ten <= '1';
                        X <= "100010010"; -- Output for state A
                    else
                        state <= B;
                        ten <= '0';
                        X <= "100001001"; -- Output for state B
                    end if;
                when B =>
                    if unsigned(timer) /= unsigned(d) then
                        state <= B;
                        ten <= '1';
                        X <= "100001001"; -- Output for state B
                    else
                        state <= C;
                        ten <= '0';
                        X <= "010100100"; -- Output for state C
                    end if;
               when C =>
                    if unsigned(timer) /= unsigned(d) then
                        state <= C;
                        ten <= '1';
                        X <= "010100100"; -- Output for state C
                    else
                        state <= E;
                        ten <= '0';
                        X <= "001100100"; -- Output for state D
                    end if;
                when E =>
                    if unsigned(timer) /= unsigned(d) then
                        state <= E;
                        ten <= '1';
                        X <= "001100100"; -- Output for state D
                    else
                        state <= A;
                        ten <= '0';
                        X <= "100010010"; -- Output for state A
                    end if;
            end case;
        end if;
    end process;
End Behavioral;


